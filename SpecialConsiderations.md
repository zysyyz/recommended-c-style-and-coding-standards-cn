## 18. 特殊考虑 ##

这节包含一些杂项：‘做'与'不做'。

  * 不要通过宏替换来改变语法。这将导致程序对于所有人都是难以理解的，除了那个肇事者。

  * 不要在需要离散值的地方使用浮点变量。使用一个浮点数作为循环计数器无疑是搬起石头砸自己的脚。总是用<=或>=测试浮点数，对它们永远不要 用精确比较(==或!=)。

  * 编译器也有bug。常见且高发的问题包括结构体赋值和位字段。你无法泛泛的预测一个编译器都有哪些bug。但你可以在程序中避免使用那些已知的在所有编译 器上都存在问题的结构。你无法让你写的任何代码都是有用的，你可能仍然会遇到bug，并且在这期间编译器很可能会被修复。因此，只有当你被强制使 用某个特定的充斥bug的编译器时，你才应该"围绕"着编译器bug写代码。

  * 不要依赖自动代码美化工具。良好代码风格的主要受益者就是代码的编写者，并且尤其在手写算法或伪代码的早期设计阶段。自动代码美化工具只应该用在那些已经 完成、语法正确并且此后不能满足当空白和缩进被更为关注的要求时。伴随着对细致程序员的细节的关注，对于那些将函数或文件布局解释清楚的工作，程 序员们会做得更好(换句话说，一些视觉布局是由意图而不是语法决定的，美化工具无法了解到程序员的思想)。粗心的程序员应该学习成为一个细致的程 序员，而不是依赖美化工具让代码可读性更好。

  * 意外地遗漏逻辑比较表达式中的第二个=是一个常犯的问题。使用显式测试。避免对赋值使用隐式测试。

```
abool = bbool;
if (abool) { ...
```

当嵌入的赋值表达式使用时，确保测试是显式的，这样后续它就无法被"修复"了。

```
while ((abool = bbool) != FALSE) { ...
while (abool = bbool) { ...    /* VALUSED */
while (abool = bbool, abool) { ...
```

  * 显式地注释那些在正常控制流之外被修改的变量，或其他可能在维护过程中中断的代码。

  * 现代编译器会自动将变量放到寄存器中。对于你认为最关键的变量慎用寄存器。在极端情况下，用寄存器标记2-4个最为关键的值，并且将剩余的标记为 REGISTER。后者在那些具有较多寄存器的机器上可以#define为寄存器。